/* -*-c++-*- VirtualPlanetBuilder - Copyright (C) 1998-2007 Robert Osfield 
 *
 * This library is open source and may be redistributed and/or modified under  
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or 
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * OpenSceneGraph Public License for more details.
*/

#ifndef HOSTS_H
#define HOSTS_H 1

#include <osg/Referenced>
#include <osg/OperationThread>

#include <vpb/Task>
#include <vpb/BuildLog>

namespace vpb
{

class VPB_EXPORT MachineOperation : public osg::Operation
{
    public:
    
        MachineOperation(Task* task);
        
        /** Use TemplateMethod pattern to case calling object to Machine.*/
        virtual void operator () (osg::Object* object);
        
        osg::ref_ptr<Task> _task;
};

class VPB_EXPORT BlockOperation : public osg::Operation, public OpenThreads::Block
{
    public:
    
        BlockOperation();

        virtual void release();

        virtual void operator () (osg::Object* object);
};
        
// forward declare to allow MachinePool and TaskManager to allow them to be declared as friends
class MachinePool;
class TaskManager;


typedef std::list< osg::ref_ptr<osg::OperationsThread> > Threads;

class VPB_EXPORT Machine : public osg::Object, public Logger
{
    public:
    
        Machine();
    
        Machine(const Machine&, const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY);

        Machine(const std::string& hostname, const std::string& commandPrefix, const std::string& commandPostfix, int numThreads=-1);
        
        META_Object(vpb, Machine)
        
        void startThreads();
        void cancelThreads();
        
        void setOperationQueue(osg::OperationQueue* queue);
        
        const std::string& getHostName() const { return _hostname; }
        const std::string& getCommandPrefix() const { return _commandPrefix; }
        const std::string& getCommandPostfix() const { return _commandPostfix; }

        int exec(const std::string& application);

        Threads& getThreads() { return _threads; }
        
        unsigned int getNumThreads() const { return _threads.size(); }

        unsigned int getNumThreadsActive() const;

        typedef std::set<Task*> RunningTasks;
        
        void startedTask(Task* task);

        void endedTask(Task* task);
        
        void taskFailed(Task* task, int result);
        
        RunningTasks& getRunningTasks() { return _runningTasks; }

        /** Send a signal to the all running tasks. */
        void signal(int signal);
        
        void setDone(bool done);
        
   protected:
    
        virtual ~Machine();
        
        friend class MachinePool;

        MachinePool*                        _machinePool;

        std::string                         _hostname;
        std::string                         _commandPrefix;
        std::string                         _commandPostfix;
        
        mutable OpenThreads::Mutex          _threadsMutex;
        Threads                             _threads;

        mutable OpenThreads::Mutex          _runningTasksMutex;
        RunningTasks                        _runningTasks;


};

class VPB_EXPORT MachinePool : public osg::Referenced, public Logger
{
    public:
    
        MachinePool();

        TaskManager* getTaskManager() { return _taskManager; }
        
        osg::OperationQueue* getOperationQueue() { return _operationQueue.get(); }

        /// override from Logger to be able to pass on to all associated Machine objects        
        void setBuildLog(BuildLog* bl);
        
        void addMachine(const std::string& hostname,const std::string& commandPrefix, const std::string& commandPostfix, int numThreads=-1);

        void addMachine(Machine* machine);
        
        void startThreads();

        void cancelThreads();

        void run(Task* Task);
        
        void waitForCompletion();
        
        void removeAllOperations();
        
        unsigned int getNumThreads() const;

        unsigned int getNumThreadsActive() const;

        void clear();
        
        bool read(const std::string& filename);

        bool write(const std::string& filename) const;

        /** Send a signal to the all running tasks. */
        void signal(int signal);
        
        void setDone(bool done);
        
        bool done() const { return _done; }
        
        void release();

        enum TaskFailureOperation
        {
            IGNORE,
            BLACKLIST_MACHINE_AND_RESUBMIT_TASK,
            COMPLETE_RUNNING_TASKS_THEN_EXIT,
            TERMINATE_RUNNING_TASKS_THEN_EXIT            
        };

        void setTaskFailureOperation(TaskFailureOperation op) { _taskFailureOperation = op; }

        TaskFailureOperation getTaskFailureOperation() const { return _taskFailureOperation; }

        /** Reset up threading and sharing of operation queue.*/
        void resetMachinePool();
        
        /** Let current tasks complete then re-read the machine pool file.*/
        void updateMachinePool();

    protected:

        virtual ~MachinePool();
        
        friend class TaskManager;

        typedef std::list< osg::ref_ptr<Machine> > Machines;

        TaskManager*                        _taskManager;
        
        std::string                         _machinePoolFileName;

        osg::ref_ptr<osg::OperationQueue>   _operationQueue;
        
        mutable OpenThreads::Mutex          _machinesMutex;
        Machines                            _machines;
        
        osg::ref_ptr<BlockOperation>        _blockOp;
        bool                                _done;

        TaskFailureOperation                _taskFailureOperation;
};

}

#endif

