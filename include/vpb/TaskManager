/* -*-c++-*- VirtualPlanetBuilder - Copyright (C) 1998-2007 Robert Osfield 
 *
 * This library is open source and may be redistributed and/or modified under  
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or 
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * OpenSceneGraph Public License for more details.
*/

#ifndef TASKMANAGER_H
#define TASKMANAGER_H 1


#include <vpb/DataSet>
#include <vpb/MachinePool>
#include <vpb/Task>

#include <map>

namespace vpb
{

class VPB_EXPORT TaskManager : public osg::Referenced, public Logger
{
    public:

        /** Singleton method used to insure that only one TaskManager ever exists.*/    
        static osg::ref_ptr<TaskManager>& instance();
    
        /// override from Logger to be able to pass on to all associated Machine objects        
        void setBuildLog(BuildLog* bl);

        /** initialize the TaskManager from application arguments and get process, host details.*/
        int read(osg::ArgumentParser& arguments);

        void setSource(osgTerrain::Terrain* terrain);
        osgTerrain::Terrain* getSource();

        /** Set the MachinePool that specifies the available machines that can be used to run the task.*/        
        void setMachinePool(MachinePool* machinePool);

        /** Get the MachinePool that specifies the available machines that can be used to run the task.*/        
        MachinePool* getMachinePool();
        
        /** start a new set of tasks.*/
        void nextTaskSet();
        
        /** add a task to the current task set.*/
        void addTask(Task* task);
        void addTask(const std::string& taskFileName);
        void addTask(const std::string& taskFileName, const std::string& application);
        
        /** build the database directly without using slaves.*/
        void buildWithoutSlaves();

        /** generate the tasks required to do a incremental/distributed build from the source definition.*/
        bool generateTasksFromSource();

        /** run all the tasks.*/
        bool run();
        
        /** Clear the TaskSetList.*/
        void clearTaskSetList();
        
        void setRunPath(const std::string& runPath);
        const std::string& getRunPath() const { return _runPath; }
        
        void setBuildName(const std::string& runPath) { _buildName; }
        const std::string& getBuildName() const { return _buildName; }
        
        /** read the task list from file.*/
        bool writeSource(const std::string& filename);

        /** read the task list from file.*/
        bool readSource(const std::string& filename);
        
        const std::string& getSourceFileName() { return _sourceFileName; }

        /** read the task list from file.*/
        bool readTasks(const std::string& filename);

        /** read the task list from file.*/
        bool writeTasks(const std::string& filename, bool asFileNames);
        
        const std::string& getTasksFileName() { return _tasksFileName; }
        
        
        /** Helper method for creating task file names.*/
        std::string createUniqueTaskFileName(const std::string application);

        typedef std::list< osg::ref_ptr<Task> > TaskSet;
        typedef std::list< TaskSet > TaskSetList;
        
        BuildOptions* getBuildOptions();
        
        bool hasMachines() const { return _machinePool->getNumThreads()!=0; }

        bool hasTasks() const { return !(_taskSetList.empty() || _taskSetList.front().empty()); }
        
        TaskSetList& getTaskSetList() { return _taskSetList; }

        
        void setDone(bool done);
        
        bool done() const { return _done; }
        

        enum SignalAction
        {
            IGNORE,
            DO_NOT_HANDLE,
            COMPLETE_RUNNING_TASKS_THEN_EXIT,
            TERMINATE_RUNNING_TASKS_THEN_EXIT,
            RESET_MACHINE_POOL,
            UPDATE_MACHINE_POOL
        };
        
        void setDefaultSignalAction(SignalAction action) { _defaultSignalAction = action; }
        SignalAction getDefaultSignalAction() const { return _defaultSignalAction; }
        
        void setSignalAction(int sig, SignalAction action);
        SignalAction getSignalAction(int sig) const;
        
        /** Send a signal to the all running tasks. */
        void handleSignal(int sig);

        /** Send terminate single to all running tasks and set done flag to true to exit from run loop.*/
        void exit(int sig);

    protected:

        TaskManager();
        virtual ~TaskManager();
        
        Task* readTask(osgDB::Input& fr, bool& itrAdvanced);
        bool writeTask(osgDB::Output& fout, const Task* task, bool asFileNames) const;
        
        static void signalHandler(int sig);
        
        std::string                         _runPath;
        std::string                         _buildName;

        osg::ref_ptr<MachinePool>           _machinePool;
        osg::ref_ptr<Task>                  _taskFile;
        
        std::string                         _sourceFileName;
        osg::ref_ptr<osgTerrain::Terrain>   _terrain;
        
        std::string                         _tasksFileName;
        TaskSetList                         _taskSetList;

        bool                                _done;
        
        typedef std::map<int, SignalAction> SignalActionMap;

        SignalAction                        _defaultSignalAction;
        SignalActionMap                     _signalActionMap;
        
        mutable OpenThreads::Mutex          _signalHandleMutex;
};

}

#endif
