/* -*-c++-*- VirtualPlanetBuilder - Copyright (C) 1998-2007 Robert Osfield 
 *
 * This library is open source and may be redistributed and/or modified under  
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or 
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * OpenSceneGraph Public License for more details.
*/

#ifndef TASKMANAGER_H
#define TASKMANAGER_H 1


#include <vpb/DataSet>
#include <vpb/MachinePool>
#include <vpb/Task>

namespace vpb
{

class VPB_EXPORT TaskManager : public osg::Referenced
{
    public:
    
        TaskManager();
        
        /** initialize the TaskManager from application arguments and get process, host details.*/
        int read(osg::ArgumentParser& arguments);

        void setSource(osgTerrain::Terrain* terrain);
        osgTerrain::Terrain* getSource();

        /** Set the MachinePool that specifies the available machines that can be used to run the task.*/        
        void setMachinePool(MachinePool* machinePool);

        /** Get the MachinePool that specifies the available machines that can be used to run the task.*/        
        MachinePool* getMachinePool();
        
        /** start a new set of tasks.*/
        void nextTaskSet();
        
        /** add a task to the current task set.*/
        void addTask(Task* task);
        void addTask(const std::string& taskFileName);
        void addTask(const std::string& taskFileName, const std::string& application);
        
        /** build the database directly without using slaves.*/
        void buildWithoutSlaves();

        /** generate the tasks required to do a incremental/distributed build from the source definition.*/
        bool generateTasksFromSource();

        /** run all the tasks.*/
        bool run();
        
        /** Clear the TaskSetList.*/
        void clearTaskSetList();
        
        void setBuildName(const std::string& buildName) { _buildName; }
        const std::string&getBuildName() const { return _buildName; }
        
        
        /** read the task list from file.*/
        bool writeSource(const std::string& filename);

        /** read the task list from file.*/
        bool readSource(const std::string& filename);
        
        const std::string& getSourceFileName() { return _sourceFileName; }

        /** read the task list from file.*/
        bool readTasks(const std::string& filename);

        /** read the task list from file.*/
        bool writeTasks(const std::string& filename);
        
        const std::string& getTasksFileName() { return _tasksFileName; }
        
        
        /** Helper method for creating task file names.*/
        std::string createUniqueTaskFileName(const std::string application);

        typedef std::list< osg::ref_ptr<Task> > TaskSet;
        typedef std::list< TaskSet > TaskSetList;
        
        BuildOptions* getBuildOptions();
        
        bool hasMachines() const { return _machinePool->getNumThreads()!=0; }

        bool hasTasks() const { return !(_taskSetList.empty() || _taskSetList.front().empty()); }
        
        TaskSetList& getTaskSetList() { return _taskSetList; }
        
    protected:

        virtual ~TaskManager();
        
        Task* readTask(osgDB::Input& fr, bool& itrAdvanced);
        bool writeTask(osgDB::Output& fout, const Task* task) const;
        
        std::string                         _buildName;

        osg::ref_ptr<MachinePool>           _machinePool;
        osg::ref_ptr<Task>                  _taskFile;
        
        std::string                         _sourceFileName;
        osg::ref_ptr<osgTerrain::Terrain>   _terrain;
        
        std::string                         _tasksFileName;
        TaskSetList                         _taskSetList;
        
};

}

#endif
